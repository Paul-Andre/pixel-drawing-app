<!doctype html>
<html>
<head>
<title>Pixel Art</title>
<script src="coreUtils.js"></script>
<script src="colorUtils.js"></script>

    <style type="text/css">
body {  padding: 0; overflow: hidden; }

#screen {  position: relative; width: 100%; height: 100%; overflow: hidden;}

    	.pageFiller {
    	margin: 10;
    		overflow: hidden;
    	}
    </style>

</head>
<body>
<div  style="top:0%; left:0%; position:fixed; width:200px; height:100%; background:red;"></div>
<div  class="pageFiller">
<canvas  id="screen" > sorry, looks like your browser doesn't have canvas support </canvas>
        
</div>

<div  style="top:0%; right:100%; position:fixed; width:200px; height:100%; background:red;"></div>        
<script>
var webcolorToBufcolor=colorUtils.webcolorToBufcolor;
var imageDataCreator=document.createElement("canvas").getContext("2d");  // I need to have a context to create imageData objects.


var canvas=document.getElementById("screen");
var ctx=canvas.getContext("2d");


function WebcolorPicture(w,h,d16){

	this.width=w-20;
	this.height=h-20;
	this.data16=d16||new Uint16Array(new ArrayBuffer(w*h*2))
}

////////////////////////////////////
/*
WebcolorPicture Transmission Format:

w: Uint16
h: Uint16
data: Uint16[w*h]  (Webcolor)

*/

WebcolorPicture.fromTransmission=function(buffer){   //    TODO Find a way to chain extractions.


	var dataView=new DataView(buffer);
	var w= dataView.getUint16(0);
	var h= dataView.getUint16(1);
	
	var data=new ArrayBuffer(w*h*2);
	var data16=new Uint16Array(data);
	
	for(var i=0; i<w*h*2; i++){
	
		data16[i]=dataView.getUint16(i);
	
	}
	
	return new WebcolorPicture(w,h,data16);

}





WebcolorPicture.prototype.toImageData=function(scale){       // TODO Optimize to reuse values for less garbage collection
																// TODO find a way to use the gpu
	
	
	var scale=scale||1;
	

	var imageData=imageDataCreator.createImageData(this.width*scale,this.height*scale);
	
	var data32=new Int32Array(imageData.data.buffer);
	
	
	
	if(scale==1) {
	
		for (var i=0; i<data32.length; i++){   //if 
		
			data32[i]=webcolorToBufcolor(this.data16[i]);
	
		}
		
	}
			
			
	
	else {
	
		for(var j=0;j<this.height;j++){ // y position
	
			for(var i=0;i<this.width;i++){   // x position
		
				for(var sj=0;sj<scale;sj++){    // y position of a same pixel if it is scaled
			
					for(var si=0;si<scale;si++){    // x position of a same pixel if it is scaled
			
			
							//alert(j+" "+i+" "+sj+" "+si+"\n"+((i*scale+si)+(j*scale+sj)*this.width)+"\n"+(i+j*this.width))
			
							data32    [ (i*scale+si)+(j*scale+sj)*this.width*scale ]      =       webcolorToBufcolor(    this.data16 [i+j*this.width]    );
							
								
									
			
					}
			
				}
		
			}
		
	
		}
		
	}
	
	return imageData;
}




window.addEventListener('resize', resizeCanvas, false);

function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

drawStuff()

}






var imageData=ctx.createImageData(100,100)
var data32=new Int32Array(imageData.data.buffer);


var color= webcolorToBufcolor(0xf04);
	
for (var i=0; i<data32.length;i++){

data32[i]=color;


}

ctx.putImageData(imageData,0,0);








var g = new WebcolorPicture(100,100);

for(i=0;i<g.data16.length;i++){

	g.data16[i]=i+i*16;

}
function drawStuff(){
	var gImageData=g.toImageData(1);
	//console.log(gImageData);
	ctx.putImageData(gImageData,0,0);
}


resizeCanvas()







</script>

</body>
</html>
