<!doctype html>
<html>
<head>
<title>Pixel Art</title>
<script src="http://code.jquery.com/jquery-1.9.1.min.js"></script>
<script src="coreUtils.js"></script>
<script src="colorUtils.js"></script>

    <style type="text/css">
body {  padding: 0; margin:0px; overflow: hidden; }

#screen {  position: relative;
 overflow: hidden;


image-rendering: optimizeSpeed;
image-rendering: -moz-crisp-edges;
image-rendering: -webkit-optimize-contrast;
-ms-interpolation-mode:nearest-neighbor;
}




#screenContainer {  position: fixed;

	margin:0px;
    		padding:0px; 
 		overflow: hidden;
 		
	top:0%
	right:200px;
	left:200px;
	
	height:100%;
	
}


    	
    	
    	
 .sideBar {
 
 	width:200px;
 
 }
 
 
    </style>

</head>
<body>
<div class="sideBar" style="top:0%; left:0%; position:fixed; height:100%; background:black;"></div>
<div class="sideBar"  style="top:0%; right:0%; position:fixed; height:100%; background:black;"></div>   
<div  id="screenContainer">

<canvas  id="screen" > sorry, looks like your browser doesn't have canvas support </canvas> 
  
</div>
     
<script>

	requestAnimationFrame = (function(){
          return  window.requestAnimationFrame       || 
                  window.webkitRequestAnimationFrame || 
                  window.mozRequestAnimationFrame    || 
                  window.oRequestAnimationFrame      || 
                  window.msRequestAnimationFrame     || 
                  function(/* function */ callback, /* DOMElement */ element){
                    window.setTimeout(callback, 1000 / 60);
                  };
    })();
	


$(".sideBar").css("width",250);
$("#screenContainer").css("left",250).css("right",250);


var webcolorToBufcolor=colorUtils.webcolorToBufcolor;
var imageDataCreator=document.createElement("canvas").getContext("2d");  // I need to have a context to create imageData objects.


var position={x:0,y:0,s:1};

function setImageSmoothing(ctx,state){

	ctx.mozImageSmoothingEnabled=state;
	ctx.webkitImageSmoothingEnabled=state;
	ctx.oImageSmoothingEnabled=state;
	ctx.msImageSmoothingEnabled=state;
	ctx.imageSmoothingEnabled=state;

}


function testCrispScaling(){

	var sourceImg=document.createElement("canvas");
	sourceImg.height =1;
	sourceImg.width = 2;
	var sourceCtx=sourceImg.getContext("2d");

	var destinationImg=document.createElement("canvas");
	destinationImg.height=2;
	destinationImg.width=4;
	var destinationCtx=sourceImg.getContext("2d");

	setImageSmoothing(destinationCtx,false)

	sourceCtx.fillStyle="#FFFFFF"
	sourceCtx.fillRect(0,0,1,1);
	sourceCtx.fillStyle="#000000"
	sourceCtx.fillRect(1,0,1,1);

	destinationCtx.drawImage(sourceImg,0,0,4,2);
	
	return (destinationCtx.getImageData(1, 0, 1, 1).data[0] == 255);

}

var CRISP_SCALABLE = testCrispScaling();


var canvas=document.getElementById("screen");
var ctx=canvas.getContext("2d");


function PixelTile(w,h,d16){

	this.width=w;
	this.height=h;

	this.webcolorData16=d16||(new Uint16Array(new ArrayBuffer(w*h*2)))
	
	this.image=document.createElement("canvas");
	this.image.width=w;
	this.image.height=h;
	this.ctx=this.image.getContext("2d");
	this.imageData=ctx.createImageData(w,h);
	this.imageData32=new Int32Array(this.imageData.data.buffer);
	
	
	this.pixelPutter=this.ctx.createImageData(1,1);
	this.pixelPutter32=new Int32Array(this.imageData.data.buffer);
	
	
	this.updateImage();
	
}


PixelTile.prototype.updateImage=function(){

		
	
	for (var i=0; i<this.webcolorData16.length; i++){   //if 
		
		this.imageData32[i]=webcolorToBufcolor(this.webcolorData16[i]);
	
	}
	
	this.ctx.putImageData(this.imageData,0,0);
	

}



PixelTile.prototype.putSinglePixel=function(x,y,webcolor){


	this.webcolorData16[x+y*this.width]=webcolor;

	this.pixelPutter32[0]=webcolorToBufcolor(webcolor);
	
	this.ctx.putImageData(this.pixelPutter,x,y);

}






////////////////////////////////////
/*
WebcolorPicture Transmission Format:

w: Uint16
h: Uint16
data: Uint16[w*h]  (Webcolor)

*/

PixelTile.fromTransmission=function(buffer){ 

	var dataView=new DataView(buffer);
	var w= dataView.getUint16(0);
	var h= dataView.getUint16(1);
	
	var data=new ArrayBuffer(w*h*2);
	var data16=new Uint16Array(data);
	
	for(var i=0; i<w*h*2; i++){
	
		data16[i]=dataView.getUint16(i);
	
	}
	
	return new PixelTile(w,h,data16);
}




function WebcolorPicture(){};


WebcolorPicture.prototype.toImageData=function(scale,x,y,w,h){       // TODO Optimize to reuse values for less garbage collection
																// TODO find a way to use the gpu
	
	
	var scale=scale||1;
	
	var x=x||0;
	var y=y||0;
	
	var w=w||this.width;
	var h=h||this.height;
	
	var imageData=imageDataCreator.createImageData((w-x)*scale,(h-y)*scale);
	
	var data32=new Int32Array(imageData.data.buffer);
	
	
	
	if(scale==1 && x==0 && y==0 && w==0 && h==0) {
	
		for (var i=0; i<data32.length; i++){   //if 
		
			data32[i]=webcolorToBufcolor(this.data16[i]);
	
		}
		
	}
			
			
	
	else {
	
		for(var j=y;j<h;j++){ // y position
	
			for(var i=x;i<w;i++){   // x position
		
				for(var sj=0;sj<scale;sj++){    // y position of a same pixel if it is scaled
			
					for(var si=0;si<scale;si++){    // x position of a same pixel if it is scaled
			
			
							//alert(j+" "+i+" "+sj+" "+si+"\n"+((i*scale+si)+(j*scale+sj)*this.width)+"\n"+(i+j*this.width))
			
							data32    [ (i*scale+si)+(j*scale+sj)*this.width*scale ]      =       webcolorToBufcolor(    this.data16 [i+j*this.width]    );
							
								
									
			
					}
			
				}
		
			}
		
	
		}
		
	}
	
	return imageData;
}


WebcolorPicture.prototype.toImage=function(scale,x,y,w,h,canvas2,ctx2){ 

		
	var scale=scale||1;
	
	var x=x||0;
	var y=y||0;
	
	var w=w||this.width;
	var h=h||this.height;
	
	var canvas=canvas2||document.createElement("canvas");
	var ctx= ctx2||canvas.getContext("2d");

	if (CRISP_SCALABLE){

		var data=this.toImageData(1,x,y,w,h);
		this.tempCanvas.width=w;
		this.tempCanvas.height=h;
		this.tempCtx.putImageData(data,0,0);
		setImageSmoothing(ctx,false);
		ctx.drawImage(this.tempCanvas,0,0,w*scale,h*scale);
		
	}
	else {
	
		var data=this.toImageData(scale,x,y,w,h);
		ctx.putImageData(data);
	}
	
	return canvas;
}



window.addEventListener('resize', resizeCanvas, false);

function resizeCanvas() {
        canvas.width = window.innerWidth-500;
        canvas.height = window.innerHeight;

drawStuff()

}








var g = new PixelTile(256,256);

var v=100;	

for(i=0;i<g.webcolorData16.length;i++){

	g.webcolorData16[i]=(i*i)*v-20;

}

	g.updateImage();


function drawStuff(){

	
	ctx.clearRect(0,0,canvas.width,canvas.height)

	setImageSmoothing(ctx,false);

	g.updateImage();
		
	ctx.drawImage(g.image,    position.x  ,    position.y ,    g.width*position.s  ,   g.height*position.s);
	
}




//resizeCanvas()

resizeCanvas();

position.x=canvas.width*0.5-g.width*0.5*position.s;
position.y=canvas.height*0.5-g.height*0.5*position.s;

drawStuff();

function cancelEvent(e)
{
  e = e ? e : window.event;
  if(e.stopPropagation)
    e.stopPropagation();
  if(e.preventDefault)
    e.preventDefault();
  e.cancelBubble = true;
  e.cancel = true;
  e.returnValue = false;
  return false;
}

function onMouseWheel(evt){
	var wheelData = evt.detail ? evt.detail/-3 : evt.wheelDelta / 120;
	
	var tile=g;
				
	var x, y;
		
	if(evt.offsetX) {
		x = evt.offsetX;
		y = evt.offsetY;
	}
	else if(evt.layerX) {
		x = evt.layerX;
		y = evt.layerY;
	}
	
	x=Math.max(position.x,Math.min(position.x+tile.width*position.s,x));
	y=Math.max(position.y,Math.min(position.y+tile.height*position.s,y));	
	
	newS=Math.max(position.s+wheelData,1);	
		
	position.x=x-(x-position.x)*newS/position.s;
	position.y=y-(y-position.y)*newS/position.s;
	
	position.x=Math.min(canvas.width*0.5,position.x);
	position.y=Math.min(canvas.height*0.5,position.y);
	
	position.x=Math.max(canvas.width*0.5-tile.width*newS,position.x);
	position.y=Math.max(canvas.height*0.5-tile.height*newS,position.y);		
	
	position.s=newS
	
	if(position.s<=2){
	
		position.x=canvas.width*0.5-tile.width*newS*0.5;
		position.y=canvas.height*0.5-tile.height*newS*0.5;
			
	}

	drawStuff();
			
	return cancelEvent(evt);
				
}

function onKeyDown(evt){
	if (evt.keyCode == 37 || evt.keyCode == 65) {position.x-=5;}
	if (evt.keyCode == 39 || evt.keyCode == 68) {position.x+=5;}
	if (evt.keyCode == 38 || evt.keyCode == 87) {position.y-=5;}
	if (evt.keyCode == 40 || evt.keyCode == 83) {position.y+=5;}
	drawStuff();
}


var mouse={1:false,2:false,3:false};
var initialMiddleMouseButtonX=0,initialMiddleMouseButtonY=0;
var initialTilePositionX=0,initialTilePositionY=0;

function onMouseDown(evt){

	var x, y;
		
	if(evt.offsetX) {
		x = evt.offsetX;
		y = evt.offsetY;
	}
	else if(evt.layerX) {
		x = evt.layerX;
		y = evt.layerY;
	}

	mouse[evt.which]=true;
	
	if(evt.which==2){
		initialMiddleMouseButtonX=x;
		initialMiddleMouseButtonY=y;
		initialTilePositionX=position.x;
		initialTilePositionY=position.y;
	}
}

function onMouseUp(evt){

	mouse[evt.which]=false;
	
	
}

function onMouseMove(evt){

	var x, y;
		
	if(evt.offsetX) {
		x = evt.offsetX;
		y = evt.offsetY;
	}
	else if(evt.layerX) {
		x = evt.layerX;
		y = evt.layerY;
	}
	
	if(mouse[2]){
	
		position.x=initialTilePositionX+(x-initialMiddleMouseButtonX);
		position.y=initialTilePositionY+(y-initialMiddleMouseButtonY);
		requestRedraw();
		//drawStuff();
	}
	
}



var requestedRedraw=false;
function requestRedraw(){

	if(!requestedRedraw){
		requestAnimationFrame(function(){drawStuff();requestedRedraw=false});
	}

}

canvas.addEventListener("mousewheel",onMouseWheel
, false);

canvas.addEventListener("DOMMouseScroll",onMouseWheel
, false);


window.addEventListener('keydown',onKeyDown,false);

window.addEventListener('mousedown',onMouseDown,false);
window.addEventListener('mouseup',onMouseUp,false);
window.addEventListener('mousemove',onMouseMove,false);


//canvas.addEventListener("")

</script>

</body>
</html>
