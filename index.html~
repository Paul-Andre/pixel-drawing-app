<!doctype html>
<html>
<head>
	<meta charset="UTF-8">
<title>Pixel Art</title>
<script src="http://code.jquery.com/jquery-1.9.1.min.js"></script>


<script src="coreUtils.js"></script>
<script src="colorUtils.js"></script>
<script src="BrowserDetect.js"></script>

    <style type="text/css">
body {  padding: 0; margin:0px; overflow: hidden; }

.mainCanvas {  position: relative;
 overflow: hidden;

	top:0px;
	
	left:0px;
image-rendering: optimizeSpeed;
image-rendering: -moz-crisp-edges;
image-rendering: -webkit-optimize-contrast;
-ms-interpolation-mode:nearest-neighbor;
}




#screenContainer {  position: fixed;

	margin:0px;
    		padding:0px; 
 		overflow: hidden;
 		
	top:0%
	right:200px;
	left:200px;
	
	height:100%;
	background-color:silver;
	
}


    	
    	
    	
 .sideBar {
 
 	width:200px;
 }
 
#colorDisplayer {

 width:200px;
 height:200px;
 display: block;
margin-left: auto;   margin-right: auto;
margin-top:5px;margin-bottom:5px;
position: relative;

border-radius: 5px;
border-style:inset;

}
 
 button.colorChoice {
 
 width:50px;
 height:50px;
 display: block;
margin-left: auto;   margin-right: auto;
margin-top:5px;margin-bottom:5px;
position: relative;

border-radius: 15px;
 
 }
 
 
 canvas.mainCanvas {
 
 
 
 
 
 
 
 
 
 }
    </style>

</head>
<body>
<div class="sideBar" style="top:0%; left:0%; position:fixed; height:100%; background:black;"></div>
<div class="sideBar"  style="top:0%; right:0%; position:fixed; height:100%; background:black;">
<div id="colorDisplayer"></div>
</button> <button class="colorChoice" id="blackButton" style="background-color:#122">
</button><button class="colorChoice" id="pinkButton" style="background-color:#ff4455 ">
</button><button class="colorChoice" id="blueButton" style="background-color:#5fa ">

</div>   
<div  id="screenContainer">

<canvas  id="screen" class="mainCanvas" > sorry, looks like your browser doesn't have canvas support </canvas> 
<canvas  id="overlay" class="mainCanvas" > </canvas> 
</div>
     
     
     
     
     
     
     
<script>

	requestAnimationFrame = (function(){
          return  window.requestAnimationFrame       || 
                  window.webkitRequestAnimationFrame || 
                  window.mozRequestAnimationFrame    || 
                  window.oRequestAnimationFrame      || 
                  window.msRequestAnimationFrame     || 
                  function(/* function */ callback, /* DOMElement */ element){
                    window.setTimeout(callback, 1000 / 60);
                  };
    })();
	



//color defs
var initialPink=0xf45;


//currentColor
var currentColor=0x122;



//jQuery commands for ui
$(".sideBar").css("width",250);
$("#screenContainer").css("left",250).css("right",250);
$("#pinkButton")
		.click(function(){
			currentColor=initialPink;
			updateDisplayer();
		});
$("#blackButton")
		.click(function(){
			currentColor=0x122;
			updateDisplayer();
		});
$("#blueButton")
		.click(function(){
			currentColor=0x5fa;
			updateDisplayer();
		});

var colorDisplayer=$("#colorDisplayer");


function updateDisplayer(){

	colorDisplayer.css("background-color", colorUtils.webcolorToCsscolor(currentColor)    )

}

	updateDisplayer();
	







//get all the canvases. 	
	
	
var mainCanvases=$(".mainCanvas");

//defining global objects and functions

var webcolorToBufcolor=colorUtils.webcolorToBufcolor;


var imageDataCreator=document.createElement("canvas").getContext("2d");  // I need to have a context to create imageData objects.


var position={x:0,y:0,s:1};


var mouse={1:false,2:false,3:false};




//functions for setting and testing crip scaling

function setImageSmoothing(ctx,state){

	ctx.mozImageSmoothingEnabled=state;
	ctx.webkitImageSmoothingEnabled=state;
	ctx.oImageSmoothingEnabled=state;
	ctx.msImageSmoothingEnabled=state;
	ctx.imageSmoothingEnabled=state;

}


function testCrispScaling(){

	var sourceImg=document.createElement("canvas");
	sourceImg.height =1;
	sourceImg.width = 2;
	var sourceCtx=sourceImg.getContext("2d");

	var destinationImg=document.createElement("canvas");
	destinationImg.height=2;
	destinationImg.width=4;
	var destinationCtx=sourceImg.getContext("2d");

	setImageSmoothing(destinationCtx,false)

	sourceCtx.fillStyle="#FFFFFF"
	sourceCtx.fillRect(0,0,1,1);
	sourceCtx.fillStyle="#000000"
	sourceCtx.fillRect(1,0,1,1);

	destinationCtx.drawImage(sourceImg,0,0,4,2);
	
	return (destinationCtx.getImageData(1, 0, 1, 1).data[0] == 255);

}

var CRISP_SCALABLE = testCrispScaling();
if(!CRISP_SCALABLE){alert("Your browser doesn't support crisp scaling in canvas.\n\nSorry, but things are going to look blurry.")};




var canvas=document.getElementById("screen");
var ctx=canvas.getContext("2d");





//  PixelTile class ///////////////////////////////////////////

function PixelTile(w,h){

	this.width=w;
	this.height=h;

	//this.webcolorData16=d16||(new Uint16Array(new ArrayBuffer(w*h*2)))
	
	this.image=document.createElement("canvas");
	this.image.width=w;
	this.image.height=h;
	this.ctx=this.image.getContext("2d");
	this.imageData=ctx.createImageData(w,h);
	this.imageData32=new Int32Array(this.imageData.data.buffer);
	
	
	this.pixelPutter=this.ctx.createImageData(1,1);
	this.pixelPutter32=new Int32Array(this.pixelPutter.data.buffer);
	
	
	//this.updateImage();
	
	this.t=this;
	
}

/*PixelTile.prototype.updateImage=function(){   // deprecated ...

		
	
	for (var i=0; i<this.webcolorData16.length; i++){   //if 
		
		this.imageData32[i]=webcolorToBufcolor(this.webcolorData16[i]);
	
	}
	
	this.ctx.putImageData(this.imageData,0,0);
	

}*/

PixelTile.prototype.putSinglePixel=function(x,y,webcolor){



	//this.webcolorData16[x+y*this.width]=webcolor;

	this.pixelPutter32[0]=webcolorToBufcolor(webcolor);
	//alert(webcolor);
	this.ctx.putImageData(this.pixelPutter,x,y);
	
	//console.log(this.t);

}

PixelTile.prototype.selectColor=function(x,y){

	var webcolor =0;

	var pixel=this.ctx.getImageData(x,y,1,1)
	
	webcolor|=(pixel.data[0] >>> 4)<<8;
	webcolor|=(pixel.data[1] >>> 4)<<4;
	webcolor|=(pixel.data[2] >>> 4)<<0;
	
	//alert(x+y*this.width);
	//alert((this.imageData.data[(x+y*this.width)*4+0] >>> 4));
	return webcolor;
}






// Code to resize the canvas when the screen is resized //////////////


window.addEventListener('resize', resizeCanvas, false);

function resizeCanvas() {


		for(var i=0;i<mainCanvases.length;i++){
				
				mainCanvases[i].width=window.innerWidth-500;
				mainCanvases[i].height=window.innerHeight;	
					
		}		
		
		drawStuff()
}














// Code that actually makes the tile and ties the ends together  //////////////////////////////////////////





var tile = new PixelTile(256*2,256*2);


for(i=0;i<tile.imageData32.length;i++){  //filling the screen with pink

	//tile.webcolorData16[i]=initialPink;
	tile.imageData32[i]=webcolorToBufcolor(initialPink);
}
//tile.updateImage();
tile.ctx.putImageData(tile.imageData,0,0);    


function drawStuff(){

	ctx.clearRect(0,0,canvas.width,canvas.height)

	setImageSmoothing(ctx,false);
		
	ctx.drawImage(tile.image,    position.x  ,    position.y ,    tile.width*position.s  ,   tile.height*position.s);
	
}

resizeCanvas();
//placing the tile in the center
position.x=canvas.width*0.5-tile.width*0.5*position.s;
position.y=canvas.height*0.5-tile.height*0.5*position.s;

drawStuff();


function selectColorFromTile(x,y){

	var x=Math.floor((x-position.x)/position.s);
	var y=Math.floor((y-position.y)/position.s);
	
	if(x>=tile.width||x<0){return false;}
	if(y>=tile.height||y<0){return false;}
	
	currentColor=tile.selectColor(x,y);
	updateDisplayer();
	
}








// canvas specific event listeners.

function cancelEvent(e)   //used to cancel all default behavior for events. Contains lots of "platform targetting" stuff. I should probably redo this.
{
  //e = e ? e : window.event;
  if(e.stopPropagation)
    e.stopPropagation();
  if(e.preventDefault)
    e.preventDefault();
  e.cancelBubble = true;
  e.cancel = true;
  e.returnValue = false;
  return false;
}

function onMouseWheel(evt){
	var wheelData = evt.detail ? evt.detail/-3 : evt.wheelDelta / 120;  // normalizing wheel data.
				
	var x, y;
		
	if(evt.offsetX) {
		x = evt.offsetX;
		y = evt.offsetY;
	}
	else if(evt.layerX) {
		x = evt.layerX;
		y = evt.layerY;
	}
	
	x=Math.max(position.x,Math.min(position.x+tile.width*position.s,x));
	y=Math.max(position.y,Math.min(position.y+tile.height*position.s,y));	
	
	newS=Math.max(position.s+wheelData,1);	
		
	position.x=x-(x-position.x)*newS/position.s;
	position.y=y-(y-position.y)*newS/position.s;
	
	position.x=Math.min(canvas.width*0.5,position.x);
	position.y=Math.min(canvas.height*0.5,position.y);
	
	position.x=Math.max(canvas.width*0.5-tile.width*newS,position.x);
	position.y=Math.max(canvas.height*0.5-tile.height*newS,position.y);		
	
	position.s=newS
	
	position.x=position.x|0;
	position.y=position.y|0;
	
	/*if(position.s<=2){
	
		position.x=canvas.width*0.5-tile.width*newS*0.5;
		position.y=canvas.height*0.5-tile.height*newS*0.5;
			
	}*/

	drawStuff();
			
	return cancelEvent(evt);
				
}

function onKeyDown(evt){
	if (evt.keyCode == 37 || evt.keyCode == 65) {position.x-=10;} //left
	if (evt.keyCode == 39 || evt.keyCode == 68) {position.x+=10;} //right
	if (evt.keyCode == 38 || evt.keyCode == 87) {position.y-=10;} //up
	if (evt.keyCode == 40 || evt.keyCode == 83) {position.y+=10;} //down
	requestRedraw();
}

var lastX=0, lastY=0;
function draw(x,y,dragging){

	if(x>=canvas.width||x<0){mouse[1]=false;return false;}
	if(y>=canvas.height||y<0){mouse[1]=false;return false;}

	var x=Math.floor((x-position.x)/position.s);
	var y=Math.floor((y-position.y)/position.s);
	
	if(x>=tile.width||x<0){mouse[1]=false;return false;}
	if(y>=tile.height||y<0){mouse[1]=false;return false;}
	

    if (dragging){
    var x1 = lastX;
    var y1 = lastY;
    var x2 = x;
    var y2 = y;
    // Define differences and error check
    var dx = Math.abs(x2 - x1);
    var dy = Math.abs(y2 - y1);
    var sx = (x1 < x2) ? 1 : -1;
    var sy = (y1 < y2) ? 1 : -1;
    var err = dx - dy;
   		// Set first coordinates
  		//  tile.putSinglePixel(y1, x1,0);
    // Main loop
    while (!((x1 == x2) && (y1 == y2))) {
      var e2 = err << 1;
      if (e2 > -dy) {
        err -= dy;
        x1 += sx;
      }
      if (e2 < dx) {
        err += dx;
        y1 += sy;
      }
      // Set coordinates
    tile.putSinglePixel(x1, y1,currentColor);
    }
    
    // http://stackoverflow.com/questions/4672279/bresenham-algorithm-in-javascript
    

	}else{
	
	
	    tile.putSinglePixel(x, y,currentColor);
	
	}

	lastX=x;
	lastY=y;
	requestRedraw();

	return true;
}


var initialMiddleMouseButtonX=0,initialMiddleMouseButtonY=0;
var initialTilePositionX=0,initialTilePositionY=0;

function onMouseDown(evt){

	var x, y;
		
	if(evt.offsetX) {
		x = evt.offsetX;
		y = evt.offsetY;
	}
	else if(evt.layerX) {
		x = evt.layerX;
		y = evt.layerY;
	}

	mouse[evt.which]=true;
	
	if(evt.which==2){
		initialMiddleMouseButtonX=x;
		initialMiddleMouseButtonY=y;
		initialTilePositionX=position.x;
		initialTilePositionY=position.y;
	}
	
	if(evt.which==1){
		
		draw(x,y);
		drawing=true;
	}
	
	if(evt.which==3){
		
		selectColorFromTile(x,y);
	}
	
	return	cancelEvent(evt);
}

function onMouseUp(evt){

	mouse[evt.which]=false;
	return	cancelEvent(evt);
	
}

function onMouseMove(evt){

	var x, y;
		
	if(evt.offsetX) {
		x = evt.offsetX;
		y = evt.offsetY;
	}
	else if(evt.layerX) {
		x = evt.layerX;
		y = evt.layerY;
	}
	
	if(mouse[2]){
	
		position.x=initialTilePositionX+(x-initialMiddleMouseButtonX);
		position.y=initialTilePositionY+(y-initialMiddleMouseButtonY);
		
		/*if(BrowserDetect.browser=="Firefox"){requestRedraw();}
		else{
			drawStuff();
		}*/
		
		
		requestRedraw();
	}
	if(mouse[1]){
		draw(x,y,true)
	}
	return	cancelEvent(evt);
}

function onMouseLeave(evt){

	mouse[1]=false;
	//mouse[2]=false;
	mouse[3]=false;
	
	return	cancelEvent(evt);
}

var requestedRedraw=false;
function requestRedraw(){

	if(!requestedRedraw){
		requestAnimationFrame(function(){drawStuff();requestedRedraw=false});
	}

}



// addEventListeners /////


canvas.addEventListener("mousewheel",onMouseWheel
, false);

canvas.addEventListener("DOMMouseScroll",onMouseWheel
, false);


window.addEventListener('keydown',onKeyDown,false);

canvas.addEventListener('mousedown',onMouseDown,false);
canvas.addEventListener('mouseup',onMouseUp,false);
canvas.addEventListener('mousemove',onMouseMove,false);
canvas.addEventListener('mouseleave',onMouseLeave,false);
canvas.addEventListener ("mouseout", onMouseLeave, false);
canvas.addEventListener('contextmenu', function(e){return cancelEvent(e);},false);

//canvas.addEventListener("")




</script>

</body>
</html>
